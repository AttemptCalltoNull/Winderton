Основываясь на том, сколько у тебя свободного времени, мы будем заниматься чуть больше года, чтобы придти к какому-то переломному моменту тебя, как программиста. Если быть точнее, то 12-15 месяцев.
Сейчас я расскажу тете о том, как можно изучать computer science.
Для начала нам нужно определится с твоим стартом и первой дисциплиной. Это важный момент, потому что если это сделать неверно, то вопросов будет намного больше, чем ответов.
Как ты помнишь из предыдущего сектора, именно у тебя есть выбор:

- Теория CS. Алгоритмы и структуры.
- Архитектура ЭВМ.
- Язык программирования

Начинать с языка я крайне не рекомендую, потому что многие вещи вроде, почему он такой, зачем делать что-то именно так, а не так, почему все языки похожи, и так далее - подобных вопросов будет тьма, и это может поспособствовать триггером для твоего перегорания. Перегорание на ранних этапах - это частое явление. 
Теория или ЭВМ?
Как показывает статистика, и те и те лагеря имеют свои плюсы, но и свои минусы.
Изучая изначально ЭВМ ты сходу идешь по пути Software Engineer'а. Что я имею ввиду? Ты сталкиваешься с фундаментальными концепциями того, как устроен компьютер, почему все именно так, как есть, что необходимо чтобы связать все эти комплексные части воедино и заставить их работать вместе. Ты узнаешь про память то, что некоторые не знаю всю жизнь. Начинаешь понимать разницу в программировании разных процессоров, и начнешь понимать что глупо сравнивать новый айфон со старым ноутбуком по производительности. Т.е. ты увидишь техники и приемы, которые использовались и используются при создании и организации железа, бОльшая часть из которых успешно используется и при проектировании программного обеспечения, которое ты и будешь писать как программист.
В случае же с Алгоритмами и структурами, ты узнаешь о другой стороне монетки.
Люди недооценивают этот топик. В университетах его подают под другим соусом, что заставляет этот топик выглядет бесполезным и не вкусным. На самом же деле, в нем есть смысл, если отнестись к нему правильно. Мы сейчас не говорим о том, что алгоритмы и структуры нужно знать для приему на работу. Сейчас мы смотрим на него как на дисциплину, которая может повлиять на наше восприятие программирования в целом.
В программировании, всегда, мы оперируем какими-то данными, с помощью каких-то алгоритмов. Это и есть разработка программного обеспечения. Все эти дополнительные уровни абстракций, в виде фреймворков, библиотек, движков и так далее - это просто огромная комбинация из трансформации данных с одной формы, в другую, с помощью тысяч различных алгоритмов.
Знание основных алгоритмов и структур данных дает тебе общее представление о том, как вообще решаются проблемы в программировании. Помни, программирование - это не знание синтаксиса языка, это решение проблем. И видя решение самым распространненых проблем, у тебя появляется это самое представление в виде, "А, так вот почему это делается так". Важный момент.
Еще, алгоритмы и структуры данных работают как математика. Ты постоянно решаешь какие-то задачи, и держишь свой мозг в состоянии, "Готов к бою". Это как тренажерка, знаешь. При встрече с чем-то реальным на продакшене, связать пару библиотек будет куда более простой задачей, нежели написать свой алгоритм сжатия и разжатия.
Делай свой выбор, а затем переходи на вторую дисциплину.
В случае начала с ЭВМ, занимаешься им первые 45 дней, по книге Introduction to computing systems. Можешь сразу пропускать 2-6 главы, и переходить сразу к Ассембли, и до конца. Задания в конце глав выполняй выборочно, и старайся делать хотя бы треть.
В книге будет много отсылок к микроархитектуре LC-3, но тебе не нужно вникать в нее. Просто имей ее ввиду.
После этой книги переходи к книге Modern x86 assembly language programming. 
Изучая ассембли, ты изучаешь железо, так как конкретный микропроцессор имеет конкретный ассембли. В нашем случае, это будет x86, самая популярная SICP архитектура на данный момент. Intel, AMD - все десктопы работают на ней, и изучая ассембли этих типов процессоров, ты изучаешь то, как они работют внутри + как они работают с разными типами памяти, что для тебя как программиста понимать критично. Этой книгой занимаешься следующие 60 дней.
Читать Эндрю Нанненбаума или Хеннеси - это уже следующий этап.
Они расписывают все от и до, и у них есть куча инфы, которая вряд ли тебе пригодится. Ее сложно выделить, потому что она есть почти в каждой главе, поэтому читать их нужно только если ты будешь заинтересован в дальнейшем изучении железа и тонкости платформы. Это чаще пригождается тем, кто собирается заниматься системным программирование, операционными системами, движками, фреймворками и так далее. Всем остальным хватает понимания которое дают первые две книги.
Во время чтения первой книги, тебе следует написать ряд проектов, таких как:
http://www.multigesture.net/articles/how-to-write-an-emulator-chip-8-interpreter/
Это написание своего эмулятора. Закрепит твое понимание платформы в основных ее местах.
https://justinmeiners.github.io/lc3-vm/
Создание виртуальной машины. Тоже самое. Для закрепления понимания того, как работает компьютер и что это такое.
Во время разбора ассембли, писать вряд ли что-то потребуется. Эта книга и этап больше будут как осмотр организации ЭВМ с другой стороны и латание дыр. Два основных проекта, которыми ты будешь заниматься для закрепления и практики ты видел выше.

Далее, следующие 60 дней ты занимаешься теорией Computer science. 
Тут все просто в выборе книг. У нас есть только 2 основные, которые все еще не потеряли в своей актуальности.
Это Томас Корман - Алгоритмы.
Это Седжвик - Алгоритмы.
Их основное различие в том, что Корман использует псевдокод, вместо реального языка программирования, а Седжвик использует Джава. Обе книги по своему хороши, но если ты не уверен с какой начать, то бери Кормана. У него подача и подход с первых глав идет проще, и статистически, в нее легче вникнуть.
Тебе нужно будет разобрать самые основные вещи, такие как:
Структуры данных:
- Связный список
- Деревья(все, что есть)
- Хеш-мапы
- Сеты
- Стэк + очередь
- Графы
Алгоритмы:
- Все сортировки
- Все поиски
- Динамическое программирование
- Алгоритмы для работы с графами

Все, что идет дальше - это уже более/менее продвинутые топики, с которыми ты столкнешься по мере изучения остального Computer Science. А что касаемо этих - то это тот самый фундамент, шаблоны, поняв которые, ты понимаешь как примерно решаются проблемы в программировании, и что из себя представляет 70-80% вообще всевозможных алгоритмических и структурных задач.
Твоя задача будет разобрать теорию по этим структурам и алгоритмам и написать их реализации. Может быть и не до конца, просто до туда, до куда сможешь дойти.
Во время попыток работы с этими топиками, ты узнаешь всю основу программирования. Переменные, массивы, указатели, циклы и тд. Именно в этот момент это будет к месту. Ты поймешь их истинные преимущества и недостатки, и поймешь как можно написать все что угодно, пользуясь буквально пятью языковыми конструкциями, и что всякие ООП, исключения, RTTI, лямды, и другие языковые фичи  - это просто синтаксический сахар, чтобы всем было проще.


Ну и на этом этапе, когда ты будешь вариться в сфере около 4-6 месяцев, ты и переходишь к детальному изучению одного из языков программирования, который тебе будет больше всего импонировать.
Java, Python, C/C++, JavaScript, Golang и так далее. Основа у них всех одна. Какие-то лучше на низком уровне, какие-то - на высоком. В каких-то есть механизмы для одного, в каких-то - для другого. Уточнять что-то нет смысла, ты сам это поймешь. Суть в том, что тебе нужно выбрать любой язык, отталкиваясь от чего угодно. Работа, личные симпатии, рекомендации и так далее.
Взять любую книгу из моей библиотеки. Там есть литература по Си, С++, Java, Python, JavaScript, C#, и подтянуть синтаксис языка + стандартные его инструменты. Дебагер, профайлер, сам компилятор + ряд других полезных утилит. Проще говоря, выучить тулчейн. Язык программирования состоит не только из спецификации. 
И попробовать не прыгать на другие языки хотя бы 2-3 месяца. У тебя будет огромное желание попробовать что-то новое. Это свойственно человеку, но попытайся контролировать эту страсть, и выучить нормально хотя бы один из языков. У тебя на этом этапе будет более 7 месяцев опыта в Comp Scie, ты будешь понимаешь принципы ЭВМ, теорию Comp Scie и как решать проблемы в целом + будешь владеть инструментом(языком программирования). У тебя будет несколько Pet проектов, которые я тебе даю + возможно ты будешь писать и придумывать что-то сам, как это часто и бывает. Но останавливаться на этом этапе будет как минимум нецелесообразно, поэтому мы перейдем к следующему топику, который даст ответы на кучу вопросов, которые у тебя на тот момент будут. Этот топик - это операционные системы.

Операционные системы.
Как ты помнишь из предыдущей главы, операционные системы - это сложнейшие куски программного обеспечения, которые отвечают за огромный спектр задач, одна из которых - это виртуализация всего железа, и представление его нам в доступном виде.
У нас, как у программистов, есть иллюзия которую нам дает операционка. Мы думаем, что ресурсы системы безграничны и она вся доступна только нам. Процессор, вся память. Поняв как именно это работает, зачем это так сделано и почему, ты прибавишь себе пару плюсиков как разработчику.
Ну а вообще, способность работать с операционной системой через ее открытый API(это что-то вроде интерфейса к ее фичам, вроде сети, графики, файловой системы, ввода/вывода и тд), это и есть разработка, на самом деле.
Фреймворки организуют в удобные модули работу со всеми этими фичами, и ты просто приходишь, пишешь одну строчку кода и вуа-ля, у тебя готовое окно. Еще строчка кода, и у тебя готовый стандартный ввод и вывод, ну и так далее. Понимая ограничения и возможности операционных систем, ты начинаешь понимать на что ты способен как программист, и какие программы ты способен писать в принципе.
По операционным системам есть одна отличная книга, которая называется Operating Systems: Principles and Practice.
Я искал альтернативы, и вроде парочку нашел(увидишь все в библиотеке), но по факту, эта книга остается пока лучший в своем жанре.
Там отлично описана Канкаренси. Там прекрасное описание работы с памятью. Подача в целом располагает к чтению, да и вообще, примеры с кодом которые встречаются работают и написаны не худшим способом, что всегда хорошо. К этой книге делают много отсылок на различных курсах по операционным системам, которые я смотрел. Как русскоязычные, так и зарубежные. Но есть и те, кто эту книгу недооценил.
Я тебе ее рекомендую.
В качестве практики, тебе нужно разобрать и написать следущие проекты:
https://www.cs.nmsu.edu/~pfeiffer/fuse-tutorial/
https://brennan.io/2015/01/16/write-a-shell-in-c/
https://github.com/tuhdo/os01
https://github.com/cfenollosa/os-tutorial
https://arjunsreedharan.org/post/82710718100/kernels-101-lets-write-a-kernel

Этих проектов будет достаточно для закрепления всего материала, который ты узнаешь из курса по операционкам. Ты уже будешь владеть языком на этом этапе, и продолжать его изучать, но тут можно начать трогать и какой-то другой, желательно С и С++, если ты начал не с них. Заметь, что я не говорю тебе сколько заниматься операционными системами, потому что топик сложный и большой(хотя, ЭВМ тоже сложный и большой), но операционки - это та абстракция, с которой ты будешь связан гораздо теснее, нежели с голым железом. Ими тебе придется прозаниматься точно около двух, а в идеале 3х месяцев, прочитав и разобрав книгу от А до Я + сделав хотя бы часть проектов. Ты постоянно будешь гуглить те или иные фичи операционной системы, под которую ты будешь программировать, это нормально, но вот понять сам кор, как она работает и из чего состоит  - это и будет заложено в твои 60-90 дней обучения.

Год спустя.
Я думаю ты тут уже и без меня будешь знать что тебе ежедневно делать, но я все оставлю еще 5 копеек.
Каждый программист в своей жизни должен написать компилятор.
Это клевые штуки, которые интересно работают и хитро устроены.
Они состоят из нескольких частей, каждая из которых несет в себе что-то фундаментальное и имеет отношение ко многим другим кускам программного обеспечения.
Парсинг, лексический анализ, интерпретация, дизассемблеры, линковщики и тому подобное. Все это связано с языками программирования, и одного лишь синтаксиса вряд ли будет достаточно, чтобы понимать плюсы и минусы разных языков даже на среднем уровне. Тебе нужно будет написать свой, это интересно.
Книга, которую я могу тебе рекомендовать по дизайну языков и компиляторам - это Engineering: a compiler. 
Раньше это был дракон, но не сейчас. Это полноценная альтернатива.
Там ты узнаешь всю необходимую теорию, посмотрим на компиляторы с разных углов, и начнешь писать свой.
В качестве закрепления всего этого материала, тебе стоит разобрать следующие проекты:
https://solarianprogrammer.com/2018/01/10/writing-minimal-x86-64-jit-compiler-cpp/
https://solarianprogrammer.com/2018/01/12/writing-minimal-x86-64-jit-compiler-cpp-part-2/
https://norasandler.com/2017/11/29/Write-a-Compiler.html
https://blog.tartanllama.xyz/writing-a-linux-debugger-setup/
Этого будет "за глаза", чтобы отпрактиковать какой бы там ни было язык программирования, углубиться в него + написать свой.
Тут твой путь начнет серьезно менять свое русло, и я уже вряд ли смогу каким бы то ни было способом на него влиять, да и это вряд ли будет нужно.
Ты будешь знать что тебе делать, когда ты просыпаешься, а это ощущение стоит очень дорого.


Я скажу лишь то, что если у тебя от куда-то возьмется свободное время и желание, и ты захочешь чего-то нового, то почитай что-нибудь про Конкретную и Дискретную математику. Эти дисциплины будут работать как шкурка, и предадут тебе как инженеру более отшлифованный вид.
Тоже самое и с Английским. Выведи этот навык на уровень максимально близкий к нативу, чтобы в ответственный момент у тебя была вся амуниция, чтобы одолеть главного боса в твоей жизни.