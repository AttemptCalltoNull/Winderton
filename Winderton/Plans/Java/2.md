Итак. Во первых, спасибо тебе за плюс $ в копилку. С умом потрачу.
Ну а теперь к делу.

Java.
Перед тем как изучать Java, ты должен само собой понять что это такое и как это работает, но более базовый вопрос, на момент написания этого плана, будет, "Зачем Java?".
Да, это полноценный язык, с развитой экосистемой, кучей решенных задач в виде фреймвороков и библиотек, огромным комьюнити и тонной вакансий по всему миру. Но так или иначе, Java - это в 80% случаев язык именно интерпрайз систем, а остальное берет Android, который сейчас активно переезжает на Kotlin. 
Java не плохо заходит как первый язык за счет своей простоты. Она учит тебя одному из важнейших навыков, который требует рынок программирования, а это умение писать и понимать ООП. Я хоть сам и не сторонник этого стиля, все же отдаю ему должное. Можешь посмотреть мой ролик про ООП, чтобы понять что я пытаюсь сейчас сказать.
Ну а вообще, java будет больше плюсом, нежели минусом, если брать ее как первый и основной язык, потому что она основана на технологиях, которые и по сей день являются чем-то важным для продакшена многих систем.

- Сама JVM - это сложная архитектурно и идейно, технология, которая решает тот же спектр задач, скажем, который решает и OpenGL. Кроссплатформенность. Это может показаться тебе чем-то обычным и невзрачным на первый взгляд, но это сильная сторона Java.
- ООП. Важный скилл-сет, который поможет тебе влиться в продакшен многих компаний, в которые ты будешь пытаться устроиться.(Я говорю сейчас о работе не просто так. Выбирая Java, ты осознанно ведешь себя в ту ветку, где ты будешь коммерческим программистом, который работает на дядю, и решает задачи, которые ему говорят решить)
- Паттерны проектирования. Изучать их просто так, для резюме - это плохая идея. Тоже самое касается и алгоритмов, и структур данных.
  
  Изучая Java, ты узнаешь о паттернах с той стороны, с которой о них нужно узнать. Книга банды четырех об этом писала красиво. Они считали корректными объектно ориентированными языками статически типизированные языки. C#/Java/C++, хотя я сам последний не считаю хорошей алтернативой в плане ООП тому же C# или Java.
  
  Смысл паттернов - это прямое отношение к ООП коду. Т.е там показаны как бы "лучшие практики" того, как можно писать рабочий ООП код, который можно поддерживать и скейлить.
- Структуры даных. Коллекции. Это один из самых популярных топиков, про которые спрашивают на собеседованиях, и не просто так.
  
  Программирование - это трансформация данных, из одной формы, в другую. Скажем, ввод с клавиатуры, в картинку на экране. Строку, в поток байтов. И так далее.
  
  А коллекции(это набор структур данных), каждая из которых помогает решить ту или иную проблему.
- JDBC. Java - это интерпрайз, помнишь? И в Java EE есть технологии, для работы с базами данных. Базы данных - это, вообще, один из главных драконов, с которым приходится бороться дефолтному Java разработчику.
- И так далее. Java вправляет мозги, в определенном смысле. +- Читабельный API, удобная работа с многопоточностью, коллекции, опять же, Лямбда выражения и так далее. Но окей, это что-то вроде мотивации изучать саму Java и что это примерно такое.
  
  Ты по знаниям сейчас +- на дне, лукавить думаю не стоит. Но это не плохо, если ты вдруг за это переживаешь. Смысл в том, что чем меньше ты знаешь, тем меньше тебя нужно будет переучивать. 
  
  Перед тем как начать говорить о самой Java, давай посмотрим на область ее применения чуть ближе, или пройдемся по теории.
  
  Java - это сервер-сайд(back-end).
  
  На серваках сейчас есть *только два языка: Java и C#. Соответственно два технологических стека: J2EE и .NET.
  
  Я имею около полугода работы именно с первым, и буду отталкиваться в основном от этого.
  
  Вообще, эти две технологии нужны для решение одних и тех же задач.
  
  У них очень похожие архитектуры, и софт, который ты делаешь, делается на на одних и тех же стандартах, и по похожим алгоритмам. Тут слишком много слова "похоже", и не зря. Эти две технологии позиционируются на рынке как конкуренты. Т.е там давно, ничего не изобретается. Ты делаешь сначала одно, потом второе, добавляешь третье, четвертое и пятое. Можешь добавить шестое, чтобы лучше работало седьмое, или добавить восьмое, чтобы лучше работало девятое и так далее. Там все по наработанной схеме. mvc, mvp, mvvm и так далее, как вариант.
  
  Т.е есть определенная последовательность действий, для создание "интерпрейз" софта. Интерпрайз софт - это просто софт гигантских размеров, который решает широкий спектр задач. Скажем, софт по контролю заболеваний какой-то страны. Просто куча данных, которые без проблем достать, если нажать пару кнопок на нужном компьютере.
  
  Для работодателей важно, чтобы ты понимал с чем тебе придется работать и как примерно работает вся эта платформа: cтек технологий, паттерны для тех или иных секторов программы, часто используемые модули языка(коллекции и тд) и все такое.
  
  Другими словами, они берут человека, который придя на рабочее место и взглянув на код базу и архитектуру приложения, будет в состоянии понять: почему тут так, там так и здесь так. Что можно трогать, а что нельзя. Если сломалось тут, то искать проблему нужно там, а не там, и так далее, так далее и так далее. А если не в состоянии понять, то хотя бы иметь желание научиться все это понимать.
  
  Есть ряд книг, которые я тебе дам, где обо всем этом можно узнать на том уровне, чтобы заехать на работу тем же самым джуном.
  
  А вообще, это все идеальное развитие событий.
  
  Чаще бывает совсем другое.
  
  Те, кто приходят собеседоваться, не имеют ни малейшего понятия о том, что есть какие-то паттерны, архитектуры, фреймворки, что код пишется по каким-то стандартам и так далее. Они просто знают синтаксис языка и может имеют пару разработок, которые они отконтраливали с помощью гитхаба, ну и на этом все(сложно поверить, но я и таких интервьюировал), поэтому старайся при изучении больше фокусироваться на software engineering'е, а не на изучении конкретных фич языка.
  
  Software engineering в данном контексте означает: обрати внимание на книги типа: Code complete, Concurrency in Action, Clean Code и так далее. Там рассказывается как раз таки про какие-то эллементарные вещи про рарзработку ПО из мира интерпрайза.
  
  Моя цель на ютабе - это обучение людей фундаментальным вещам.
  
  Основам различных теоретических и практических топиков компьютерных наук(в общем смысле, +- так и есть). Это то, что на мой взгляд важно, если ты планируешь заниматься в жизни чем-то серьезным. Но когда речь идет о поддержке в WEBе, (где тебе и придется работать), то эти принципы там мало играют роль. Почему?
  
  Потому что там уже есть все необходимые технологии, для решения любого спектра задач. Никто даже и не разбирается, как они работают. Это никому там не нужно. Люди просто учатся ими пользоваться, и далее делают то, что зарабатывает деньги компании. Люди там решают проблемы на уровне склеивания уже огромной кучи библиотек и различных модулей, и если у тебя вдруг что-то не работает, то как правило, вы пишите какой-то костыль, ну или если повезло, и у вас есть в команде пару норм разрабов, то можно попытаться это пофиксить в руте.
  
  Короче говоря, я не буду тебе советовать изучать то, как работает твоя единственная платформа(железо), или как устроена операционная система. Десктопная, серверная, не важно. Не буду советовать изучать теорию дизайна языков программирования, чтобы понимать, почему язык такой, какой он есть.
  
  Это все важно, да, но это отнимет у тебя минимум год+, и ты слабо продвинешься к тому, чтобы найти работу в принципе. 
  
  Ну чтож, окей. Java - это мир интерпрайза, куча работы с базами данных, легаси кода и так далее. Давай конкретнее.
  
  Во первых, Java или C#?
  
  Я бы советовал пикать C#, потому что он как язык лучше, но если ты живешь в СНГ, и собираешься тут работать, то тогда Java, потому что просто напросто вакансий больше, ну а вообще, эти языка как бы "интерчейнджебл", или взаимозаменяемы. Я знаю несколько ситуаций, где люди хотели работать с одним, но работают с другим стеком и все окей.
  
  Майкрософтовский стек находится в одном месте, в то время как джавовский стек валяется по всему интернету и его нужно собирать своими руками. (Сейчас с этим стало все лучше, но раньше было у жасно)
  
  Джава работает везде, C# только на винде и Виндосовских серваках(Но это не совсем тру и сейчас есть различные прослойки, чтобы работало тоже везде. Тот же самый Ксамарин только чего стоит).
  
  Джава - это такая технология, которая преобладает преимущественно в: Индии, России и СНГ. Т.е в бедных странах. Есть ряд причин почему так, но это больше экономическая составляющая, а не программирование. Типа, серваки майкрософта стоят голды, а джаву можно и на линуксах разворачивать, что априори дешевле.
  
  Т.е да, во первых, тебе нужно вытягивать язык хотя бы на какой-то уровень, и это будет твоим первым драконом.
  
  В идеале, ты должен быть способен читать чужой код и понимать, что происходит, нажав кнопку "запустить", но тут дело только практики. Нужно писать код хотя бы час в день, а в идеале больше. Даже не обязательного его писать. Нужно просто с ним работать. Смотреть на него, редачить, читать, дебажить, профайлить и так далее.
  
  Джава-core отлично описывается в книгах тоже Шилдта, и я сам считаю их лучшим, с чего можно начать по Java(в плане литературы). По продвинутой Java - это конечно же Блок, Effective Java. Эта книга - это что-то вроде библии по Java. Там челик пытается объяснить, как программировать хоть что-то, используя Java, в отличии от Шилдта, который рассказывает дефолтный референс(но делает это хорошо).
  
  Окей. Что же нам нужно учить с самой Java, потому что язык объемный, и ты не можешь позволить себе потратить время, чтобы разбирать сразу каждый угол Java.

Во первых, ты изначально пытаешься разобраться с JVM и идей смой Java. Разбираешь то, как реализована jvm, ее архитектура, принцип работы. Каким образом Java работает кроссплатформенно, разбираешь различные платформы(java se, java ee, java me).
Далее офк синтаксис. Тут все стандартно, как и в любом языке.

- Операторы
- типы данных(примитивы)
- Идея ООП
- классы/объекты
- ветвления
- строки, массивы
- циклы

Это будет твоим базизом и основой. Перед тем как идти дальше, и изучать другие фичи java, нужно основательно разобраться с этими.

Далее твое основное внимание должно пасть именно на OOP. 
Основные его принципы, альтернативы(ECS, императивная процедурка, stateless и тд).
Особый фокус сделать на наследовании. 
Разобраться с переопределением и перегрузкой.
Научиться делать классы изменяемыми(динамическими)
Учиться моделировать код, на основе объектов из реального мира(это одна из основных идей ООП). Так же разбираешься с полиморфизмом. Статическим и динамическим. Не игнорируй оператор instansof(многие так и делают). Разбираешься основу модификаторов доступа.(public, privat и тд). Разбираешь что такое static. Тут бы помогли фундаментальные знания и понимание различного рода памяти, ее организации и так далее, но к этому ты всему придешь со временем. Такой уж путь ты выбрал.
На этом этапе ты должен быть уже способен пользоваться лучшими практиками ООП и вообще, java, и быть способным реализовать хотя бы singleton + быть способным работать с приведением типов(в этом хорошо помогает понимание наследования и полиорфизма).

Следующий уровень. Уже что-то вроде "продвинутой java".
Абстрактные классы. Интерфейсы. Сама Лямбда. Стримы. Обработка исключений. Это все работает как вспомогательный саб-сет java. Можно писать код, который будет отлично работать, не прибегая к этим фичам, но они крайне удобны, и считаются хорошим тоном. Особенно интерфейсы.
Обработка исключений - это вообще 70% всего кода на java, и с ними нужно дружить.

Структуры данных/коллекции. Как ты помнишь, это один из самых важных топиков в Java, и на этом этапе ты начинаешь с ними работать плотнее. В java механизм реализации коллекций - это обобщенное программирование, generics. Помню, когда я работал, мне мой тим лид пытался втереть то, что generics - это будущее java. Ну а вообще, он был в чем-то прав. Темплейты, generics и тд - это упрощает жизнь, в некоторых случаях.
Ты должен будешь понимать что такое arrrayList, linkedList, hashtable, queue, tree, list, set. Хотя бы так, для начала. Это самый распространенный список структур, которые используются на продакшене + это то, о чем спрашивают на собеседованиях. Некоторые из них даже просят реализовать на бумаге(но это не сложно), когда ты понимаешь, как они работают и для чего нужна та или иная.

Тут, в принципе, ты будешь знать java-core. Можешь быть в этом уверен. Да, конечно же, я предполагаю что ты будешь изучать все эти фичи на должном уровне, а не просто почитывая книжку на досуге. Т.е ты должен их практиковать, пытаться понять, а не просто заучивать, гуглить то, что кажется абсурдом, задавать вопросы и так далее. Это работает только так.

IO, многопоточность, потоки(streams) и так далее - это все уже хай-левел java, т.е к этому переходят когда уже что-то способны делать используя core, поэтому - да, всему свое время.

Но java - это не только синтаксис и какие-то странные фичи, вроде рефлексии. Java - это целый стек технологий, который используется для решения бизнес проблем, поэтому давай пройдемся и по ним.

Базы данных.(JDBC)
Тут без вариантов. Это то, с чем тебе придется работать.
Это целый топик вообще, и я не сказал бы, что в нем шарю.
У меня есть небольшой опыт работы с реляционными базами данных, а именно с MySQL.
Там нужно знать сам язык баз данных SQL, само собой + какие-то СУБД. MySQL СУБД, например, это такая огромная система, где можно создавать и управлять базами данных либо с помощью не противного UI, либо прям из под терминала. Ребят, кто с этим знаком оч любят во многих конторах.
Так же, касаемо баз данных, там есть различные под системы, типа ORM, (hibernate). Это такая штука, которая позволяет оборачивать в java объект SQL запросы, и манипулировать ими как объектами Java(ты это потом поймешь). Ну и бла бла бла. Это все учиться за пару недель, чтобы решать большинство задач, но если выводить уровень до "Гуру в базах данных", то и года не хватит.
Т.е тут полно всяких тонкостей. Да, ты вряд ли станешь админом баз данных в Оракле, но уметь сделать так, чтобы кто-то ввел запрос, и ты смог его обработать, прокатить, например, через созданный тобою же парсер/агрегатор и в развернутом(flexible)виде показать то, что попросил пользователь, - это да, ты должен будешь уметь. У меня есть прикольная книга под базам данных. Найдешь в библиотеке.

Далее, системы сборки.
У нас был Maven, когда я работал.
В .NET есть всякие MSBuild, mAnt и так далее.
Это системы для сборки всего того, что ты там напишешь.
Т.е ты будешь использовать ряд технологий, типа: серверов приложений, парт тайм компиляторов, скриптинга и так далее, и вот эти билд инструменты позволят тебе собирать проект таким образом, каким ты пожелаешь, в зависимости от ситуации. Т.е это вроде конфугируторов. Так как стеки технологические огромные, то делать все ручками постоянно - это напряжно, и вот билд системы - это спасение.
У тебя, возможно, будут свои персональные конфиги, где, скажем, сервак можно поднять за 30 секунд для какого-то теста, в то время как стандартное поднятие сервера занимает больше 5 минут.
Скажем, придет тим лид, и скажет, покажите что у нас есть в общих чертах. Ты билдишь все так, чтобы работал основной сервер, без лишних выебонов, и он запускается за 10 секунд, в то время как если бы ты запустил стандартный конфиг сборки, то у тебя бы поднялся Весь ваш сервак, с блэк джеком и шлюхами. Ты это все еще узнаешь.

Паттерны проектирования.
Опять же, Это вроде договоренностей, основываясь на которых, разрабы между собой могут комуницировать. Т.е ты видишь код и понимаешь, что и как там работает, не понимая детальной реализации, а основываясь на том, какие паттерны там использованы. Это абсолютный топик и его просто нужно выучить и понять. Паттрены имеют прямое отношение к проектированию и ООП. Есть одна книга по всем этим топикам, которая написана четырьмя крутыми мужиками. Я тебе советую ее почитать. О ней узнаешь позже.

Алгоритмы и структуры(коллекции).
Это крайне важная тема, потому что ты конструируешь сэты из данных, с помощью коллекций, и работаешь с ними с помощью различных алгоритмов.
Основные из них и которые чаще всего встречаются - есть во всех +- хороших книгах по алгоримам. У меня есть в библиотеке одна их них. Вообще, именно в Java, как и ты и хочешь, коллекции и обобщенное программирование реализовано очень удобно.
Effective Java, в ней ты найдешь прям кучу полезного о всяких там коллекциях, дженериках и так далее. Ее рекомендуют читать всем Java разрабам, начиная с самих Джунов.

Фронт-энд.
Да, тебе нужно знать и его. Это важно для того, что фронт-энд плотно работает с бэк-эндом, и скажем, когда я работал, то я написал валидатор, который контролировал следующим образом:

- чтобы не ввелось в любое поле нашего приложения(на фронт-энде), то это бы прогонялось через соответствующий валидатор, который работал на стороне клиента.Видишь, т.е хоть я и был сервер-сайд разрабом, я должен был понимать как работает front-end.
  
  Тут как бы изи: html, css и javascript.

Системы контроля версий.
Тут тоже без вариантов.
Это очень удобные технологии, которые позволяют контролировать весь цикл разработки. Если ты ими не умеешь пользоваться, то это автоматом означает, что ты не делал ничего, кроме примитивных калькуляторов на 200 строк кода. Т.е советую разобраться как работает хотя бы git(самая популярная из них), и попользоваться одним из сервисов, где он(git) является ядром, типа: bitbucket, github и тд.
Просто что-то спрограммировать, и отконтролить весь цикл разработки с помощью github'а. Очень полезный опыт.

Еще есть тема знать о тестировании, но я в этом плане вообще днище, поэтому ничего сказать не могу. Т.е я не пользуюсь юнит тестами, TDD и тому подобным, потому что знаю что и где может сделать мой код, ну или пытаюсь сделать так, чтобы я это знал. Но это не значит, что ты тоже должен так делать. Напротив, если ты будешь так делать работая в какой-нибудь конторе, то по голове тебя явно не погладят.
Если кратко, то тесты - это методы, которые проверяют на прочность другие твои методы. Как-то так. Я никогда не пишу тесты, потому что это скучно.

На этом этапе, у тебя будет солидное понимание Java-core + некоторых углублений в саму java платформу. Ты будешь знать ряд допов, вроде баз данных, основы мордобилдинга(front-end), дефолтных билд тулзов и тому подобное.
На этом этапе, ты сможешь выбирать свой дальнейший путь.
У тебя их будет грубо говоря 3:

- android
- enterprise
- web

Второй и третий идут бок о бок. Просто в случае со вторым(enterprise), ты будешь еще заниматься и десктопом, и разбирать всякие там swing, fx и так далее. У них свои проблемы, и там много работы именно в одном потоке(это своеобразный подход к программированию). +, конечно же это сервера, браузерные клиенты и все остальное. Там нужно будет разбирать Spring core, и его особенность вроде MVC нативного, как реализуется безопасность в этом гиганте, как он работает с WEB платформой и куча всего остального. Spring - это, наверное, один из самых сложных и комплексных фреймвороков на данный момент.

Касаемо же Android, то тут уже совершенно, другая, история...
Думаю если бы ты хотел заниматься android, то ты бы об этом прямо и сказал, но этого небыло, поэтому я оставлю этот сектор покрытый тайной и мраком.

Идеи для практики:

- https://medium.com/programmers-blockchain/create-simple-blockchain-java-tutorial-from-scratch-6eeed3cb03fa
- https://medium.com/@SeloSlav/how-to-make-a-scary-russian-twitter-bot-with-java-b7b62768a3ac
  - https://avik-das.github.io/build-your-own-raytracer/
  - http://blog.rogach.org/2015/08/how-to-create-your-own-simple-3d-render.html
  - http://jakubdziworski.github.io/categories.html#Enkel-ref
  - https://www.youtube.com/playlist?list=PLgCYzUzKIBE9HUJU-upNvl3TRVAo9W47y
  - В общем, если ты будешь знать все то, что я тебе тут сказал, ты сможешь пройти больше 80% интервью вообще без проблем, и остальные 20% c проблемами. Просто сейчас уже нет такого, когда можно просто знать язык и пройти на работу. Хотя, если ты реально будешь хорошо знать язык, то это будет автоматом значить, что ты знаешь как работает ОС, компиляторы и так далее. Т.е люди будут знать, что ты знаешь устройство и принцип сложных систем и как они работают, и для тебя, запрограммировать что-то типа сервера для интернет магазина вряд ли будет проблемой, поэтому, тут не все так однозначно.
    
    Если же ты не такой уникум, то работодатель просто будет ожидать о тебя того, что ты уже что-то писал использовал то, о чем я рассказал выше, в той или иной степени. Если ты написал даже простую авторизацию пользователя, используя все сказанное выше, то это огромный плюс. Т.е опыт - наше все. Просто на том, что ты читаешь книги, пишешь реализации алгоритмов, или задачки с Джава Раша ты далеко не уедешь. реальные задачи отличаются в разы. "пример с авторизацией".
